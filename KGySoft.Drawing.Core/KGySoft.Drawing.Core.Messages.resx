<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="General_OperationCanceled" xml:space="preserve">
    <value>The operation was canceled.</value>
  </data>
  <data name="General_InvalidAsyncResultFormat" xml:space="preserve">
    <value>Either the IAsyncResult object did not come from the corresponding '{0}' method, or the End method was called multiple times with the same IAsyncResult.</value>
  </data>
  <data name="General_InternalErrorFormat" xml:space="preserve">
    <value>Internal Error: {0}</value>
  </data>
  <data name="General_PixelFormatInvalidFormat" xml:space="preserve">
    <value>Pixel format '{0}' does not represent an actual format.</value>
  </data>
  <data name="Imaging_InvalidOperationIndexedOnly" xml:space="preserve">
    <value>This method can be used only on bitmaps with indexed pixel format.</value>
  </data>
  <data name="Imaging_QuantizerInitializeNull" xml:space="preserve">
    <value>The IQuantizer.Initialize method returned a null reference.</value>
  </data>
  <data name="Imaging_DithererInitializeNull" xml:space="preserve">
    <value>The IDitherer.Initialize method returned a null reference.</value>
  </data>
  <data name="Imaging_NotBitmapDataStream" xml:space="preserve">
    <value>Not a valid bitmap data stream.</value>
  </data>
  <data name="Imaging_InvalidBitmapDataSize" xml:space="preserve">
    <value>The bitmap data has an invalid size.</value>
  </data>
  <data name="Imaging_StrideTooSmallFormat" xml:space="preserve">
    <value>For the given pixel format and width stride must not be less than {0}.</value>
  </data>
  <data name="Imaging_StrideInvalidFormat" xml:space="preserve">
    <value>For element type '{0}' stride must be a multiple of {1}.</value>
  </data>
  <data name="Imaging_StrideFormatInvalidFormat" xml:space="preserve">
    <value>For known pixel format '{0}' stride must be a multiple of {1}.</value>
  </data>
  <data name="Imaging_BufferLengthTooSmallFormat" xml:space="preserve">
    <value>The specified buffer should have at least {0} elements for the specified size, stride and pixel format.</value>
  </data>
  <data name="Imaging_PixelWidthInvalidFormat" xml:space="preserve">
    <value>For buffer element type '{0}' and known pixel format '{1}', the pixel width multiplied by {2} must be a multiple also of {3}.</value>
  </data>
  <data name="Imaging_InvalidPaletteIndexFormat" xml:space="preserve">
    <value>Palette index {0} is invalid. It must be greater than or equal to 0 and less than palette count {1}.</value>
  </data>
  <data name="Imaging_NonIndexedPixelFormatExpected" xml:space="preserve">
    <value>A non-indexed pixel format is expected.</value>
  </data>
  <data name="Imaging_IndexedPixelFormatExpected" xml:space="preserve">
    <value>An indexed pixel format is expected.</value>
  </data>
  <data name="Imaging_WidthTooLarge" xml:space="preserve">
    <value>The specified width is too large for the given buffer width and pixel format.</value>
  </data>
  <data name="Imaging_IndexedPixelFormatTooLarge" xml:space="preserve">
    <value>An indexed pixel format should not be larger than 16 bits per pixel.</value>
  </data>
  <data name="Imaging_InvalidPremultipliedValues" xml:space="preserve">
    <value>For a premultiplied color the alpha value should not be smaller than the color components.</value>
  </data>
  <data name="Imaging_InvalidArgbValues" xml:space="preserve">
    <value>One or more color components are out of range.</value>
  </data>
  <data name="Imaging_CustomBitmapDataWriteOnly" xml:space="preserve">
    <value>This custom bitmap data is write-only so it does not support getting pixels.</value>
  </data>
  <data name="Imaging_CustomBitmapDataReadOnly" xml:space="preserve">
    <value>This custom bitmap data is read-only so it does not support setting pixels.</value>
  </data>
  <data name="Imaging_NoPixelAccessSpecified" xml:space="preserve">
    <value>At least one of the pixel access delegates should be specified.</value>
  </data>
  <data name="Imaging_UnmanagedBufferTooLarge" xml:space="preserve">
    <value>Cannot create a clone of the unmanaged bitmap of this size because the created buffer would be too large.</value>
  </data>
  <data name="Imaging_PaletteTooLargeFormat" xml:space="preserve">
    <value>Palette must not have more than {0} colors for a pixel format of {1} bits per pixel.</value>
  </data>
  <data name="GifEncoder_CannotChangeProperty" xml:space="preserve">
    <value>This property cannot be set after adding the first image.</value>
  </data>
  <data name="GifEncoder_PaletteTooLarge" xml:space="preserve">
    <value>The palette must not have more than 256 colors.</value>
  </data>
  <data name="GifEncoder_CommentTooLong" xml:space="preserve">
    <value>GIF comments cannot be longer than 255 characters.</value>
  </data>
  <data name="GifEncoder_CommentNotAscii" xml:space="preserve">
    <value>GIF comments can consist of ASCII characters only.</value>
  </data>
  <data name="GifEncoder_AnimationContainsNoFrames" xml:space="preserve">
    <value>Encoder options did not return any frames.</value>
  </data>
  <data name="GifEncoder_NullFrame" xml:space="preserve">
    <value>Encoder options returned a null frame. You must initialize GifEncodingOptions with an enumeration that does not have a null element.</value>
  </data>
  <data name="GifEncoder_UnexpectedFrameSize" xml:space="preserve">
    <value>A frame had an unexpected size. Set the GifEncodingOptions.SizeHandling property to allow different input sizes.</value>
  </data>
  <data name="Shapes_BezierPointsInvalid" xml:space="preserve">
    <value>If not zero or one points are specified, then the number of points minus one should be divisible by 3.</value>
  </data>
  <data name="Shapes_StartEndTooClose" xml:space="preserve">
    <value>Start and end points are too close to each other.</value>
  </data>
</root>