#region Copyright

///////////////////////////////////////////////////////////////////////////////
//  File: InterleavedGradientNoiseDitherer.cs
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) KGy SOFT, 2005-2023 - All Rights Reserved
//
//  You should have received a copy of the LICENSE file at the top-level
//  directory of this distribution.
//
//  Please refer to the LICENSE file if you want to use this source code.
///////////////////////////////////////////////////////////////////////////////

#endregion

#region Usings

using System;
using System.Diagnostics.CodeAnalysis;

using KGySoft.Threading;

#endregion

namespace KGySoft.Drawing.Imaging
{
    /// <summary>
    /// Provides an <see cref="IDitherer"/> implementation for applying an interleaved gradient noise pattern to the dithered result. For other noise-like
    /// ditherers see the <see cref="OrderedDitherer.BlueNoise">OrderedDitherer.BlueNoise</see> property and the <see cref="RandomNoiseDitherer"/> class.
    /// </summary>
    /// <remarks>
    /// <note>The noise generated by the <see cref="InterleavedGradientNoiseDitherer"/> is not random but based on a formula so using the
    /// same source image, quantizer and strength produces always the same result (similarly to the <see cref="OrderedDitherer.BlueNoise"/> ditherer,
    /// which is based on <see cref="OrderedDitherer">ordered dithering</see>).
    /// To dither images with real random noise use the <see cref="RandomNoiseDitherer"/>, which applies white noise to the quantized source.</note>
    /// <para>The following table demonstrates the effect of the dithering:
    /// <table class="table is-hoverable">
    /// <thead><tr><th width="50%"><div style="text-align:center;">Original image</div></th><th width="50%"><div style="text-align:center;">Quantized image</div></th></tr></thead>
    /// <tbody>
    /// <tr><td><div style="text-align:center;">
    /// <para><img src="../Help/Images/AlphaGradient.png" alt="Color hues with alpha gradient"/>
    /// <br/>Color hues with alpha gradient</para></div></td>
    /// <td><div style="text-align:center;">
    /// <para><img src="../Help/Images/AlphaGradientDefault8bppSilver.gif" alt="Color hues with system default 8 BPP palette and silver background"/>
    /// <br/>Quantizing with <see cref="PredefinedColorsQuantizer.SystemDefault8BppPalette">system default 8 BPP palette</see>, no dithering</para>
    /// <para><img src="../Help/Images/AlphaGradientDefault8bppSilverDitheredIGN.gif" alt="Color hues with system default 8 BPP palette, using silver background and interleaved gradient noise dithering"/>
    /// <br/>Quantizing with <see cref="PredefinedColorsQuantizer.SystemDefault8BppPalette">system default 8 BPP palette</see> and interleaved gradient noise dithering</para></div></td>
    /// </tr>
    /// <tr><td><div style="text-align:center;">
    /// <para><img src="../Help/Images/GrayShades.gif" alt="Grayscale color shades with different bit depths"/>
    /// <br/>Grayscale color shades</para></div></td>
    /// <td><div style="text-align:center;">
    /// <para><img src="../Help/Images/GrayShadesBW.gif" alt="Grayscale color shades with black and white palette"/>
    /// <br/>Quantizing with <see cref="PredefinedColorsQuantizer.BlackAndWhite">black and white palette</see>, no dithering</para>
    /// <para><img src="../Help/Images/GrayShadesBWDitheredIGN.gif" alt="Grayscale color shades with black and white palette using interleaved gradient noise dithering"/>
    /// <br/>Quantizing with <see cref="PredefinedColorsQuantizer.BlackAndWhite">black and white palette</see> and interleaved gradient noise dithering</para></div></td>
    /// </tr>
    /// </tbody></table></para>
    /// </remarks>
    /// <seealso cref="IDitherer" />
    /// <seealso cref="OrderedDitherer" />
    /// <seealso cref="ErrorDiffusionDitherer" />
    /// <seealso cref="InterleavedGradientNoiseDitherer" />
    public sealed class InterleavedGradientNoiseDitherer : IDitherer
    {
        #region Nested Classes

        #region InterleavedGradientNoiseDitheringSessionSrgb class

        private sealed class InterleavedGradientNoiseDitheringSessionSrgb : VariableStrengthDitheringSessionSrgbBase
        {
            #region Properties

            public override bool IsSequential => false;

            #endregion

            #region Constructors

            internal InterleavedGradientNoiseDitheringSessionSrgb(IQuantizingSession quantizingSession, InterleavedGradientNoiseDitherer ditherer)
                : base(quantizingSession)
            {
                if (ditherer.strength > 0f)
                {
                    Strength = ditherer.strength;
                    return;
                }

                Strength = CalibrateStrength(-127, 127, false);
            }

            #endregion

            #region Methods

            protected override sbyte GetOffset(int x, int y)
            {
                static double Frac(double value) => value - Math.Floor(value);

                // Generating values between -127 and 127 so completely white/black pixels will not change
                // The formula is taken from here: https://bartwronski.com/2016/10/30/dithering-part-three-real-world-2d-quantization-dithering/
                return (sbyte)(Frac(52.9829189 * Frac(0.06711056 * x + 0.00583715 * y)) * 256 - 128);
            }

            #endregion
        }

        #endregion

        #region InterleavedGradientNoiseDitheringSessionLinear class

        private sealed class InterleavedGradientNoiseDitheringSessionLinear : VariableStrengthDitheringSessionLinearBase
        {
            #region Properties

            public override bool IsSequential => false;

            #endregion

            #region Constructors

            internal InterleavedGradientNoiseDitheringSessionLinear(IQuantizingSession quantizingSession, InterleavedGradientNoiseDitherer ditherer)
                : base(quantizingSession)
            {
                if (ditherer.strength > 0f)
                {
                    Strength = ditherer.strength;
                    return;
                }

                Strength = CalibrateStrength(MinOffset, MaxOffset, true);
            }

            #endregion

            #region Methods

            protected override float GetOffset(int x, int y)
            {
                static double Frac(double value) => value - Math.Floor(value);

                // The formula is taken from here: https://bartwronski.com/2016/10/30/dithering-part-three-real-world-2d-quantization-dithering/
                return (float)(Frac(52.9829189 * Frac(0.06711056 * x + 0.00583715 * y)) * (MaxOffset - MinOffset) + MinOffset);
            }

            #endregion
        }

        #endregion

        #endregion

        #region Fields

        #region Instance Fields

        private readonly float strength;

        #endregion

        #endregion

        #region Properties

        bool IDitherer.InitializeReliesOnContent => false;

        #endregion

        #region Constructors

        /// <summary>
        /// Initializes a new instance of the <see cref="InterleavedGradientNoiseDitherer"/> class.
        /// </summary>
        /// <param name="strength">The strength of the dithering effect between 0 and 1 (inclusive bounds).
        /// Specify 0 to use an auto value for each dithering session based on the used quantizer.
        /// <br/>See the <strong>Remarks</strong> section of the <see cref="OrderedDitherer"/> class for more details and some examples regarding dithering strength.
        /// The same applies also for the <see cref="InterleavedGradientNoiseDitherer"/> class. This parameter is optional.
        /// <br/>Default value: <c>0</c>.</param>
        /// <example>
        /// The following example demonstrates how to use the <see cref="InterleavedGradientNoiseDitherer"/> class.
        /// <code lang="C#"><![CDATA[
        /// public static IReadWriteBitmapData ToDitheredInterleavedGradientNoise(IReadWriteBitmapData source, IQuantizer quantizer)
        /// {
        ///     IDitherer ditherer = new InterleavedGradientNoiseDitherer();
        ///
        ///     // a.) this solution returns a new bitmap data and does not change the original one:
        ///     return source.Clone(quantizer.PixelFormatHint, quantizer, ditherer);
        ///
        ///     // b.) alternatively, you can perform the dithering directly on the source bitmap data:
        ///     source.Dither(quantizer, ditherer);
        ///     return source;
        /// }]]></code>
        /// <para>The example above may produce the following results:
        /// <table class="table is-hoverable">
        /// <thead><tr><th width="50%"><div style="text-align:center;">Original image</div></th><th width="50%"><div style="text-align:center;">Quantized and dithered image</div></th></tr></thead>
        /// <tbody>
        /// <tr><td><div style="text-align:center;">
        /// <para><img src="../Help/Images/AlphaGradient.png" alt="Color hues with alpha gradient"/>
        /// <br/>Color hues with alpha gradient</para></div></td>
        /// <td><div style="text-align:center;">
        /// <para><img src="../Help/Images/AlphaGradientDefault8bppSilverDitheredIGN.gif" alt="Color hues with system default 8 BPP palette, using silver background and interleaved gradient noise dithering"/>
        /// <br/>Quantizing with <see cref="PredefinedColorsQuantizer.SystemDefault8BppPalette">system default 8 BPP palette</see></para></div></td>
        /// </tr>
        /// <tr><td><div style="text-align:center;">
        /// <para><img src="../Help/Images/GrayShades.gif" alt="Grayscale color shades with different bit depths"/>
        /// <br/>Grayscale color shades</para></div></td>
        /// <td><div style="text-align:center;">
        /// <para><img src="../Help/Images/GrayShadesBWDitheredIGN.gif" alt="Grayscale color shades with black and white palette using interleaved gradient noise dithering"/>
        /// <br/>Quantizing with <see cref="PredefinedColorsQuantizer.BlackAndWhite">black and white palette</see></para></div></td>
        /// </tr>
        /// </tbody></table></para>
        /// </example>
        public InterleavedGradientNoiseDitherer(float strength = 0f)
        {
            if (Single.IsNaN(strength) || strength < 0f || strength > 1f)
                throw new ArgumentOutOfRangeException(nameof(strength), PublicResources.ArgumentMustBeBetween(0, 1));
            this.strength = strength;
        }

        #endregion

        #region Methods

        [SuppressMessage("ReSharper", "ConditionalAccessQualifierIsNonNullableAccordingToAPIContract",
            Justification = "It CAN be null, just must no be. Null check is in the called ctor.")]
        IDitheringSession IDitherer.Initialize(IReadableBitmapData source, IQuantizingSession quantizingSession, IAsyncContext? context)
            => quantizingSession?.PrefersLinearColorSpace == true
                ? new InterleavedGradientNoiseDitheringSessionLinear(quantizingSession, this)
                : new InterleavedGradientNoiseDitheringSessionSrgb(quantizingSession!, this);

        #endregion
    }
}
